<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Compressor - Privacy First</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“¸</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #f5f5f7;
      line-height: 1.6;
      overflow-x: hidden;
    }

    .hero {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 60px 20px;
      background: linear-gradient(180deg, #000 0%, #1a1a1a 100%);
    }

    .hero-title {
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 600;
      letter-spacing: -0.03em;
      margin-bottom: 20px;
      background: linear-gradient(90deg, #fff 0%, #999 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .hero-subtitle {
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      font-weight: 400;
      color: #86868b;
      margin-bottom: 30px;
      max-width: 800px;
    }

    .security-tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #10b981;
      padding: 12px 24px;
      border-radius: 50px;
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 50px;
      backdrop-filter: blur(10px);
    }

    .upload-section {
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }

    .upload-zone {
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 20px;
      padding: 80px 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      background: rgba(255,255,255,0.03);
      backdrop-filter: blur(20px);
    }

    .upload-zone:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.05);
      transform: scale(1.01);
    }

    .upload-zone.dragover {
      border-color: #0071e3;
      background: rgba(0,113,227,0.1);
    }

    .upload-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      filter: grayscale(0.3);
    }

    .upload-text {
      font-size: 1.5rem;
      font-weight: 500;
      color: #f5f5f7;
      margin-bottom: 10px;
    }

    .upload-subtext {
      color: #86868b;
      font-size: 1rem;
    }

    #fileInput {
      display: none;
    }

    .preview-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 1000;
      backdrop-filter: blur(20px);
    }

    .preview-modal.active {
      display: block;
    }

    .modal-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 60px 40px;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .modal-title {
      font-size: 1.8rem;
      font-weight: 600;
      color: #f5f5f7;
    }

    .close-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: none;
      color: #f5f5f7;
      font-size: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .close-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: rotate(90deg);
    }

    .comparison-container {
      flex: 1;
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      background: #1a1a1a;
      margin-bottom: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .comparison-wrapper {
      position: relative;
      max-width: 100%;
      max-height: 100%;
      display: inline-block;
    }

    .comparison-images {
      position: relative;
      user-select: none;
    }

    .comparison-img {
      display: block;
      max-width: 100%;
      max-height: 70vh;
      width: auto;
      height: auto;
    }

    .compressed-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 50%;
      height: 100%;
      overflow: hidden;
    }

    .compressed-layer img {
      position: absolute;
      top: 0;
      left: 0;
      max-width: none;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .slider-handle {
      position: absolute;
      top: 0;
      left: 50%;
      width: 4px;
      height: 100%;
      background: #0071e3;
      cursor: ew-resize;
      transform: translateX(-50%);
      z-index: 10;
    }

    .slider-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: #0071e3;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 20px rgba(0,113,227,0.5);
    }

    .slider-arrow {
      width: 0;
      height: 0;
      border-style: solid;
      position: absolute;
    }

    .slider-arrow-left {
      border-width: 8px 12px 8px 0;
      border-color: transparent #fff transparent transparent;
      left: 16px;
    }

    .slider-arrow-right {
      border-width: 8px 0 8px 12px;
      border-color: transparent transparent transparent #fff;
      right: 16px;
    }

    .image-labels {
      position: absolute;
      top: 20px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 20px;
      pointer-events: none;
    }

    .label {
      background: rgba(0,0,0,0.7);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 500;
      backdrop-filter: blur(10px);
    }

    .label-original {
      color: #ff3b30;
    }

    .label-compressed {
      color: #10b981;
    }

    .controls {
      background: rgba(255,255,255,0.05);
      border-radius: 20px;
      padding: 30px;
      backdrop-filter: blur(20px);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #86868b;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #f5f5f7;
    }

    .stat-value.savings {
      color: #10b981;
    }

    .quality-control {
      margin-bottom: 30px;
    }

    .quality-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .quality-label {
      font-size: 1rem;
      color: #f5f5f7;
    }

    .quality-value {
      font-size: 1.2rem;
      font-weight: 600;
      color: #0071e3;
    }

    .quality-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      background: linear-gradient(90deg, #ff3b30 0%, #ffcc00 50%, #10b981 100%);
      cursor: pointer;
    }

    .quality-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .quality-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      border: none;
    }

    .action-buttons {
      display: flex;
      gap: 15px;
    }

    .btn {
      flex: 1;
      padding: 16px 32px;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
    }

    .btn-primary {
      background: #0071e3;
      color: #fff;
    }

    .btn-primary:hover {
      background: #0077ed;
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(0,113,227,0.3);
    }

    .btn-secondary {
      background: rgba(255,255,255,0.1);
      color: #f5f5f7;
    }

    .btn-secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    .algorithm-badge {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,113,227,0.2);
      border: 1px solid rgba(0,113,227,0.4);
      color: #0071e3;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 500;
      backdrop-filter: blur(10px);
      pointer-events: none;
    }

    .processing-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      z-index: 20;
    }

    .processing-overlay.active {
      display: flex;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top-color: #0071e3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }

    .processing-text {
      color: #86868b;
      font-size: 0.9rem;
      margin-top: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .features {
      max-width: 1000px;
      margin: 100px auto;
      padding: 20px;
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 40px;
      margin-top: 60px;
    }

    .feature {
      text-align: center;
    }

    .feature-icon {
      font-size: 3rem;
      margin-bottom: 20px;
      filter: grayscale(0.3);
    }

    .feature-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: #f5f5f7;
      margin-bottom: 10px;
    }

    .feature-description {
      color: #86868b;
      font-size: 1rem;
      line-height: 1.6;
    }

    @media (max-width: 768px) {
      .modal-content {
        padding: 40px 20px;
      }

      .stats {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .action-buttons {
        flex-direction: column;
      }

      .comparison-img {
        max-height: 50vh;
      }
    }
  </style>
</head>
<body>
  <div class="hero">
    <h1 class="hero-title">Image Compressor</h1>
    <p class="hero-subtitle">Advanced AI-powered compression with multi-pass optimization</p>
    <div class="security-tag">
      ðŸ”’ 100% Private â€¢ No Server Upload â€¢ Zero Data Collection
    </div>
    
    <div class="upload-section">
      <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">ðŸ“¸</div>
        <div class="upload-text">Drop your images here</div>
        <div class="upload-subtext">or click to browse â€¢ JPEG, PNG, WEBP</div>
      </div>
      <input type="file" id="fileInput" accept="image/jpeg,image/png,image/webp" multiple>
    </div>
  </div>

  <div class="features">
    <div class="features-grid">
      <div class="feature">
        <div class="feature-icon">ðŸ§ </div>
        <h3 class="feature-title">Smart Subject Detection</h3>
        <p class="feature-description">AI algorithm detects subjects and preserves detail while aggressively compressing backgrounds</p>
      </div>
      <div class="feature">
        <div class="feature-icon">âš¡</div>
        <h3 class="feature-title">Multi-Pass Optimization</h3>
        <p class="feature-description">Advanced multi-pass compression with adaptive format selection for optimal results</p>
      </div>
      <div class="feature">
        <div class="feature-icon">ðŸ”’</div>
        <h3 class="feature-title">Complete Privacy</h3>
        <p class="feature-description">Your images never leave your device. Zero tracking, zero data collection</p>
      </div>
    </div>
  </div>

  <div class="preview-modal" id="previewModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="modalTitle">Image Preview</h2>
        <button class="close-btn" onclick="closePreview()">Ã—</button>
      </div>

      <div class="comparison-container">
        <div class="algorithm-badge">AI Multi-Pass Active</div>
        <div class="processing-overlay" id="processingOverlay">
          <div class="spinner"></div>
          <div class="processing-text">Analyzing and optimizing...</div>
        </div>
        
        <div class="comparison-wrapper" id="comparisonWrapper">
          <div class="comparison-images" id="comparisonImages">
            <img id="originalImg" class="comparison-img" alt="Original">
            <div class="compressed-layer" id="compressedLayer">
              <img id="compressedImg" alt="Compressed">
            </div>
            <div class="slider-handle" id="sliderHandle">
              <div class="slider-button">
                <div class="slider-arrow slider-arrow-left"></div>
                <div class="slider-arrow slider-arrow-right"></div>
              </div>
            </div>
            <div class="image-labels">
              <span class="label label-original">Original</span>
              <span class="label label-compressed">Compressed</span>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="stats">
          <div class="stat-item">
            <div class="stat-label">Original Size</div>
            <div class="stat-value" id="originalSize">--</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Compressed Size</div>
            <div class="stat-value" id="compressedSize">--</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Savings</div>
            <div class="stat-value savings" id="savings">--</div>
          </div>
        </div>

        <div class="quality-control">
          <div class="quality-header">
            <span class="quality-label">Compression Quality</span>
            <span class="quality-value" id="qualityValue">80%</span>
          </div>
          <input type="range" class="quality-slider" id="qualitySlider" min="10" max="100" value="80">
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" onclick="downloadCompressed()">Download Compressed</button>
          <button class="btn btn-secondary" onclick="closePreview()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentImage = null;
    let isDragging = false;

    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const previewModal = document.getElementById('previewModal');
    const sliderHandle = document.getElementById('sliderHandle');
    const compressedLayer = document.getElementById('compressedLayer');
    const qualitySlider = document.getElementById('qualitySlider');
    const processingOverlay = document.getElementById('processingOverlay');

    uploadZone.addEventListener('click', () => fileInput.click());

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
      if (files.length > 0) handleFile(files[0]);
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) handleFile(e.target.files[0]);
    });

    async function handleFile(file) {
      currentImage = {
        file: file,
        name: file.name,
        originalSize: file.size,
        type: file.type
      };

      const img = await loadImage(file);
      currentImage.img = img;

      document.getElementById('modalTitle').textContent = file.name;
      document.getElementById('originalImg').src = img.src;
      document.getElementById('originalSize').textContent = formatBytes(file.size);

      previewModal.classList.add('active');
      await compressWithQuality(0.8);
      
      updateSliderPosition(50);
    }

    async function compressWithQuality(quality) {
      processingOverlay.classList.add('active');
      
      await new Promise(resolve => setTimeout(resolve, 300));
      
      const compressed = await advancedCompress(currentImage.img, quality, currentImage.type);
      currentImage.compressed = compressed.blob;
      currentImage.compressedSize = compressed.blob.size;
      
      document.getElementById('compressedImg').src = compressed.dataUrl;
      document.getElementById('compressedSize').textContent = formatBytes(compressed.blob.size);
      
      const savings = ((1 - compressed.blob.size / currentImage.originalSize) * 100).toFixed(1);
      document.getElementById('savings').textContent = savings + '%';
      
      processingOverlay.classList.remove('active');
    }

    async function advancedCompress(img, quality, mimeType) {
      // Adaptive scaling: only scale down if image is too large
      const maxMegapixels = 4;
      const currentMegapixels = (img.width * img.height) / 1000000;
      let targetWidth = img.width;
      let targetHeight = img.height;
      
      if (currentMegapixels > maxMegapixels) {
        const scaleFactor = Math.sqrt(maxMegapixels / currentMegapixels);
        targetWidth = Math.floor(img.width * scaleFactor);
        targetHeight = Math.floor(img.height * scaleFactor);
      }
      
      const canvas = document.createElement('canvas');
      canvas.width = targetWidth;
      canvas.height = targetHeight;
      
      const ctx = canvas.getContext('2d', { 
        alpha: true,
        willReadFrequently: false
      });
      
      // High quality downscaling
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
      
      // Get image data for analysis and preprocessing
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Analyze image characteristics for adaptive encoding
      const analysis = analyzeImage(imageData);
      
      // Preprocess based on image type and quality
      preprocessImage(imageData, analysis, quality);
      
      // Apply smart subject detection and selective compression
      const edges = detectEdges(imageData);
      applySelectiveCompression(imageData, edges, quality);
      
      ctx.putImageData(imageData, 0, 0);
      
      // Determine optimal format based on image characteristics
      const optimalFormat = determineOptimalFormat(analysis, quality, mimeType);
      
      // Multi-pass compression for better results
      return await multiPassCompress(canvas, optimalFormat, quality);
    }
    
    function analyzeImage(imageData) {
      const data = imageData.data;
      const pixelCount = imageData.width * imageData.height;
      let entropy = 0;
      let hasAlpha = false;
      let colorCount = new Set();
      
      // Sample pixels for performance (every 4th pixel)
      for (let i = 0; i < data.length; i += 16) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];
        
        if (a < 255) hasAlpha = true;
        
        // Track unique colors (simplified)
        const colorKey = (r << 16) | (g << 8) | b;
        colorCount.add(colorKey);
        
        // Calculate local variance for entropy estimation
        if (i > 4) {
          const diff = Math.abs(r - data[i - 4]) + 
                      Math.abs(g - data[i - 3]) + 
                      Math.abs(b - data[i - 2]);
          entropy += diff;
        }
      }
      
      const avgEntropy = entropy / (pixelCount / 4);
      const uniqueColorRatio = colorCount.size / (pixelCount / 4);
      
      return {
        hasAlpha,
        entropy: avgEntropy,
        uniqueColorRatio,
        isPhotographic: avgEntropy > 30 && uniqueColorRatio > 0.3,
        isGraphic: avgEntropy < 20 || uniqueColorRatio < 0.2
      };
    }
    
    function preprocessImage(imageData, analysis, quality) {
      const data = imageData.data;
      
      // Apply gamma correction for better perceptual quality
      const gamma = quality < 0.5 ? 1.1 : 1.0;
      const gammaCorrection = 1 / gamma;
      
      // Color space optimization
      for (let i = 0; i < data.length; i += 4) {
        // Gamma correction
        if (gamma !== 1.0) {
          data[i] = Math.pow(data[i] / 255, gammaCorrection) * 255;
          data[i + 1] = Math.pow(data[i + 1] / 255, gammaCorrection) * 255;
          data[i + 2] = Math.pow(data[i + 2] / 255, gammaCorrection) * 255;
        }
        
        // Chroma subsampling preparation for low quality
        if (quality < 0.6 && !analysis.isGraphic) {
          // Convert to YCbCr and reduce chroma precision
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          const y = 0.299 * r + 0.587 * g + 0.114 * b;
          const cb = -0.169 * r - 0.331 * g + 0.5 * b + 128;
          const cr = 0.5 * r - 0.419 * g - 0.081 * b + 128;
          
          // Reduce chroma precision
          const cbReduced = Math.round(cb / 4) * 4;
          const crReduced = Math.round(cr / 4) * 4;
          
          // Convert back to RGB
          data[i] = Math.max(0, Math.min(255, y + 1.402 * (crReduced - 128)));
          data[i + 1] = Math.max(0, Math.min(255, y - 0.344 * (cbReduced - 128) - 0.714 * (crReduced - 128)));
          data[i + 2] = Math.max(0, Math.min(255, y + 1.772 * (cbReduced - 128)));
        }
      }
    }
    
    function determineOptimalFormat(analysis, quality, originalMimeType) {
      // True lossless for maximum quality
      if (quality >= 0.99) {
        return {
          type: 'image/webp',
          quality: 1.0
        };
      }
      
      // WebP for graphics and text
      if (analysis.isGraphic) {
        return {
          type: 'image/webp',
          quality: Math.max(0.85, quality)
        };
      }
      
      // For photographs, use original format with optimization
      if (originalMimeType === 'image/jpeg' || originalMimeType === 'image/jpg') {
        return {
          type: 'image/jpeg',
          quality: quality
        };
      }
      
      // Default to WebP for best compression
      return {
        type: 'image/webp',
        quality: quality
      };
    }
    
    async function multiPassCompress(canvas, format, quality) {
      // First pass: standard compression
      const firstPass = await compressPass(canvas, format.type, quality);
      
      // If quality is high or size is already good, return first pass
      if (quality > 0.8) {
        return firstPass;
      }
      
      // Second pass: try slightly lower quality for better compression
      const secondQuality = quality * 0.95;
      const secondPass = await compressPass(canvas, format.type, secondQuality);
      
      // Return the better result (smaller with acceptable quality difference)
      const sizeDiff = firstPass.blob.size - secondPass.blob.size;
      const sizeReduction = sizeDiff / firstPass.blob.size;
      
      // If we save more than 5% with minimal quality loss, use second pass
      if (sizeReduction > 0.05) {
        return secondPass;
      }
      
      return firstPass;
    }
    
    async function compressPass(canvas, mimeType, quality) {
      return new Promise((resolve) => {
        canvas.toBlob((blob) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            resolve({ blob, dataUrl: reader.result });
          };
          reader.readAsDataURL(blob);
        }, mimeType, quality);
      });
    }

    function detectEdges(imageData) {
      const width = imageData.width;
      const height = imageData.height;
      const data = imageData.data;
      const edges = new Uint8Array(width * height);
      
      // Sobel edge detection (simplified)
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          
          // Calculate gradient
          const gx = (
            -data[idx - 4 - width * 4] + data[idx + 4 - width * 4] +
            -2 * data[idx - 4] + 2 * data[idx + 4] +
            -data[idx - 4 + width * 4] + data[idx + 4 + width * 4]
          );
          
          const gy = (
            -data[idx - width * 4 - 4] - 2 * data[idx - width * 4] - data[idx - width * 4 + 4] +
            data[idx + width * 4 - 4] + 2 * data[idx + width * 4] + data[idx + width * 4 + 4]
          );
          
          const magnitude = Math.sqrt(gx * gx + gy * gy);
          edges[y * width + x] = magnitude > 50 ? 255 : 0;
        }
      }
      
      return edges;
    }

    function applySelectiveCompression(imageData, edges, quality) {
      const width = imageData.width;
      const height = imageData.height;
      const data = imageData.data;
      const radius = Math.floor((1 - quality) * 3);
      
      if (radius < 1) return;
      
      // Apply slight blur to non-edge areas (background)
      for (let y = radius; y < height - radius; y++) {
        for (let x = radius; x < width - radius; x++) {
          const idx = y * width + x;
          
          // Skip if it's an edge (subject area)
          if (edges[idx] > 128) continue;
          
          let r = 0, g = 0, b = 0, count = 0;
          
          // Average surrounding pixels for background areas
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const pixelIdx = ((y + dy) * width + (x + dx)) * 4;
              r += data[pixelIdx];
              g += data[pixelIdx + 1];
              b += data[pixelIdx + 2];
              count++;
            }
          }
          
          const currentIdx = idx * 4;
          data[currentIdx] = r / count;
          data[currentIdx + 1] = g / count;
          data[currentIdx + 2] = b / count;
        }
      }
    }

    // Slider functionality
    function initSlider() {
      sliderHandle.addEventListener('mousedown', startDragging);
      sliderHandle.addEventListener('touchstart', startDragging);
      
      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', drag);
      
      document.addEventListener('mouseup', stopDragging);
      document.addEventListener('touchend', stopDragging);
    }

    function startDragging(e) {
      isDragging = true;
      e.preventDefault();
    }

    function drag(e) {
      if (!isDragging) return;
      
      const container = document.getElementById('comparisonImages');
      const rect = container.getBoundingClientRect();
      const x = (e.type.includes('touch') ? e.touches[0].clientX : e.clientX) - rect.left;
      const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
      
      updateSliderPosition(percentage);
    }

    function stopDragging() {
      isDragging = false;
    }

    function updateSliderPosition(percentage) {
      sliderHandle.style.left = percentage + '%';
      compressedLayer.style.width = percentage + '%';
    }

    qualitySlider.addEventListener('input', async (e) => {
      const quality = e.target.value / 100;
      document.getElementById('qualityValue').textContent = e.target.value + '%';
    });

    qualitySlider.addEventListener('change', async (e) => {
      const quality = e.target.value / 100;
      await compressWithQuality(quality);
    });

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function downloadCompressed() {
      if (!currentImage || !currentImage.compressed) return;
      
      const url = URL.createObjectURL(currentImage.compressed);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'compressed_' + currentImage.name;
      a.click();
      URL.revokeObjectURL(url);
    }

    function closePreview() {
      previewModal.classList.remove('active');
      fileInput.value = '';
      currentImage = null;
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
    }

    initSlider();
  </script>
</body>
</html>
